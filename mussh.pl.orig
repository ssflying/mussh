#!/usr/bin/env perl
use warnings;
use strict;
use Cwd;
use Net::OpenSSH;
use Getopt::Long;
use Parallel::ForkManager;
use Data::Dumper;
use Pod::Usage;

# set default values
my %opt = (
    user		=> $ENV{USER},
    method		=> "key",
    key			=> "~/.ssh/id_rsa",

    connect_timeout	=> 10,
    command_timeout	=> 60,
    sync_timeout	=> 200,
    bwlimit		=> 10240,
    
    max_proc		=> 200,
    debug		=> 0,
);

# processing command lines
GetOptions(
    'help|h'                 => \$opt{help},
    'debug=i'               => \$opt{debug},
    'max-proc=i'            => \$opt{max_proc},

    'connect-timeout=i'     => \$opt{connect_timeout},
    'command-timeout=i'     => \$opt{command_timeout},
    'sync-timeout=i'        => \$opt{sync_timeout},
    'bwlimit=i'             => \$opt{bwlimit},

    'host|h=s'              => \$opt{host},
    'user|u=s'              => \$opt{user},
    'passwd|p=s'	    => \$opt{passwd},
    'method|m=s'	    => \$opt{method},
    'key-file|i:s'          => \$opt{key},

    'remote-cmd|c=s'        => \$opt{remote_cmd},
    'push-files|s=s{,}'     => \@{$opt{push_files}},
    'pull-files|g=s{,}'     => \@{$opt{pull_files}},
    'local-dir|l=s'         => \$opt{local_dir},
    'remote-dir|r=s'        => \$opt{remote_dir},
) or pod2usage(2);
pod2usage(1) if $opt{help};

# debug on/off
my $debug = $opt{debug};
$Net::OpenSSH::debug |= 16 if $debug > 1;

# initial ssh options
my %opts_ssh = (
    port => "36000",
    ssh_cmd => "/usr/bin/ssh",
    strict_mode => 0,
    master_opts => [
        -o => "StrictHostKeyChecking=no"
    ],
    user => $opt{user},
);

# determine ssh authentication method
# then set approciate ssh options
if($opt{method} eq "key") {
    $opts_ssh{key_path} = $opt{key};
    $opts_ssh{batch_mode} = 1;
} elsif($opt{method} eq "password") {
    $opts_ssh{passwd} = $opt{passwd} || $ENV{ABSPASSWD};
    print "password empty!\n" unless $opts_ssh{passwd};
} else {
    pod2usage(2);
}

print Dumper(\%opts_ssh) if $debug;

#######################
## opts for command
########################
my %opts_command;
$opts_command{timeout}  = $opt{command_timeout}; 

#######################
# opts for sync
#######################
my %opts_sync = (
    bwlimit     => $opt{bwlimit},
    archive     => 1,
    compress    => 1,
);
if ( $debug >= 1 ) {
    $opts_sync{verbose}  = 1;
    $opts_sync{progress} = 1;
} else {
    $opts_sync{quiet}    = 1,
}

$opts_sync{timeout} = $opt{sync_timeout} if $opt{sync_timeout};
$opts_sync{bwlimit} = $opt{bwlimit} if $opt{bwlimit};

#######################
# push and pull file
#######################
my $work_dir = getcwd;
my (@push_files, @pull_files);
if ( @{$opt{push_files}} > 0 ) {
    @push_files = map { "$work_dir/" . $_ if m/\b(?=[^\/])/ } @{$opt{push_files}};
    foreach ( @push_files) {
        die "ERR: push file: $_ not found\n" unless -f $_ or -d $_;
    }
    $opt{remote_dir} = '/tmp' unless defined $opt{remote_dir};
}

if ( @{$opt{pull_files}} > 0 ) {
    @pull_files = split /\s+/, @{$opt{pull_files}};
    $opt{local_dir} = '/tmp' unless defined $opt{local_dir};
    die "ERR: local dir: $_ not found\n" unless -d $opt{local_dir};
}

# get ip list
my %ip_list;
if ( -f "$opt{host}" ) {
    open FH_IP, "$opt{host}" or die "ERR: open $opt{host} failed: $!";
    while ( <FH_IP> ) {
	next unless /^(?:\d{1,3}\.){3}\d{1,3}/;
	chomp;
	my ($ip, $info) = split /\s+/;
	$ip_list{$ip} = $info || "" ;
    }
    close FH_IP;
} elsif ( "$opt{host}" =~ /^(?:\d{1,3}\.){3}\d{1,3}/ ) {
    $ip_list{$opt{host}} = "";
} else {
    die "invalid value for --host/-h, check --help\n";
}

print Dumper(\%ip_list) if $debug;

my @hosts = keys %ip_list;
my $ip_num = @hosts;
die("ERR: no ip found") if $ip_num < 1;
my $max_proc = $opt{max_proc} > $ip_num ? $ip_num : $opt{max_proc};

sub ssh_job {
    my ($ip, $return) = @_;

    my $ssh_file = $debug >= 1 ? "log/master.$ip.log" : "/dev/null";
    open my $fh, ">$ssh_file" or die "$!";

    $opts_ssh{master_stderr_fh} = $fh,
    my $ssh = Net::OpenSSH->new($ip, %opts_ssh);
    # when set async => 1, will never go here
    if ( $ssh->error ) {
        $return->{ssherr} = "ssh connect failed: " . $ssh->error;
        return 3;
    }
    close $fh;

    # push files to remote dir
    if ( @{$opt{push_files}} > 0 ) {
        $ssh->rsync_put( \%opts_sync, @push_files, $opt{remote_dir});
        if ( $ssh->error ) {
            $return->{ssherr} = "rsync push failed: " . $ssh->error;
            return 3;
        }
    }
    
    if ( $opt{remote_cmd} ) {
        ($return->{stdout}, $return->{stderr}) = $ssh->capture2(\%opts_command, "$opt{remote_cmd}");
        if ( $ssh->error ) {
            $return->{ssherr} = "operation didn't complete successfully: " . $ssh->error;
        }
    }
    
    if ( @{$opt{pull_files}} > 0 ) {
        mkdir "$opt{local_dir}/$ip" unless -d "$opt{local_dir}/$ip";

        $ssh->rsync_get( \%opts_sync, @pull_files, "$opt{local_dir}/$ip");
        if ( $ssh->error ) {
            $return->{ssherr} = "rsync pull failed: " . $ssh->error;
            return 3;
        }
    }
}

# start fork
my $pm = new Parallel::ForkManager($max_proc);
my @results;
$pm->run_on_finish ( # called BEFORE the first call to start()
    sub {
	my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $return) = @_;

	if (defined($return)) {  # children are not forced to send anything
		push @results, $return;
	} else {  # problems occuring during storage or retrieval will throw a warning
	    print qq|No message received from child process $pid!\n|;
	}
    }
);
for my $h ( @hosts ) {
    $pm->start and next;	# do the fork
    my %return = (
	ip => $h,
    );
    ssh_job($h, \%return);
    $pm->finish(0, \%return);
}
$pm->wait_all_children;

sub show_results {
    my @results = @_;
    my $i = @results;
    for my $r (@results) {
	$r->{'stdout'} =~ s/^/$i\t$r->{'ip'}\t/mg;
	print $r->{'stdout'};
	if($r->{'stderr'}) {
	    $r->{'stderr'} =~ s/^/$i\t$r->{'ip'}\t/mg;
	    print STDERR $r->{'stderr'};
	}
	--$i;
    }
}

show_results(@results);
__END__

=head1 NAME

	Mussh - Multi hosts ssh management tools

=head1 SYNOPSIS

	mussh.pl [OPTIONS] 

=head1 DESCRIPTION

	mussh execute commands on multihosts, push local files to remote hosts, or pull remote files back to 
	the local directory. It's the essential task for most SA, and is helpful fo implement some centralized
	monitor.

=head1 AUTHOR

	alickchen@tencent(Qingsu Chen)

=head1 BUGS

	need document

=head1 SEE ALSO

	Net::OpenSSH Parallel::ForkManager rsync(1)

=head1 COPYRIGHT

	this program is free software. You may copy or redistribute it under the same terms as Perl itself.
